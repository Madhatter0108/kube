=KUBERNETES: 


ARCHITECURE:

Consists of below mentioned components.

1. API SERVER.
2. SCHEDULER.
3. KUBELET.
4. ETCD.
5. 


Kubelet will take




==============
Installation
--------------
1. Hard Way. (Manual installtion of all components like kubectl, kubelet, api server, scheduler etc)
2. Kubeadm ( utility). We download utility in kube master and cluster node, run it. it will install component kubectl, kubelet, api server etc 
3. Cloud prvoider. Pre-build kube cluster available in cloud providers like aws(EKS) and google cloud(GKE).

===============
Installation of Kube cluster with kubeadm utility

Step 1: Done on both Master and Node

Install Docker on all nodes, containerization tool used in this kube cluster.

Download kubeadm on all >>>


Step 2: 


Step3: Done on kube cluster. 

run token on kube node. 

================

In kubernetes we will not create container directly, we will create a pod. On top of pod we will create replicaset, service 
Pod will take image from containerization tool running and will create container inside it. 


Layer of abstraction on top of container. 
Container will not have ip address, while POD will have and it will be responsible of all communication. 

Kubernetes objects are persistent entities in the Kubernetes system. Kubernetes uses these entities to represent the state of your cluster. Specifically, they can describe:

    What containerized applications are running (and on which nodes)
    The resources available to those applications
    The policies around how those applications behave, such as restart policies, upgrades, and fault-tolerance

A Kubernetes object is a "record of intent"--once you create the object, the Kubernetes system will constantly work to ensure that object exists. By creating an object, you're effectively telling the Kubernetes system what you want your cluster's workload to look like; this is your cluster's desired state.

To work with Kubernetes objects--whether to create, modify, or delete them--you'll need to use the Kubernetes API. When you use the kubectl command-line interface, for example, the CLI makes the necessary Kubernetes API calls for you. You can also use the Kubernetes API directly in your own programs using one of the Client Libraries.
Object Spec and Status

Almost every Kubernetes object includes two nested object fields that govern the object's configuration: the object spec and the object status. For objects that have a spec, you have to set this when you create the object, providing a description of the characteristics you want the resource to have: its desired state.

The status describes the current state of the object, supplied and updated by the Kubernetes system and its components. The Kubernetes control plane continually and actively manages every object's actual state to match the desired state you supplied.

For example: in Kubernetes, a Deployment is an object that can represent an application running on your cluster. When you create the Deployment, you might set the Deployment spec to specify that you want three replicas of the application to be running. The Kubernetes system reads the Deployment spec and starts three instances of your desired application--updating the status to match your spec. If any of those instances should fail (a status change), the Kubernetes system responds to the difference between spec and status by making a correction--in this case, starting a replacement instance.

Kubernetes has several objects:
1. Pod. 


================
POD >> Smallest unit that can be deployed in kubernetes
----------------

basic command >> single command to create pod on kubernetes cluster. 

kubectl run pod1 --image nginx

kubectl get nodes               >>> TO GET KUBERNETES CLUSTER DETAILS. 
kubectl get pod                 
kubectl get pod -o wide
kubectl describe pod pod1

now we use manifest in companies 
kubectl explain pod | less


KIND:     Pod
VERSION:  v1

DESCRIPTION:
     Pod is a collection of containers that can run on a host. This resource is
     created by clients and scheduled onto hosts.

FIELDS:
   apiVersion   <string>
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources

   kind <string>
     Kind is a string value representing the REST resource this object
     represents. Servers may infer this from the endpoint the client submits
     requests to. Cannot be updated. In CamelCase. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds

   metadata     <Object>
     Standard object's metadata. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata

   spec <Object>
     Specification of the desired behavior of the pod. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

   status       <Object>
     Most recently observed status of the pod. This data may not be up to date.
     Populated by the system. Read-only. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

======================
Example:
======================
In manifest we need to fill the template for Pod ( apiVersion, kind, metadata, spec). 


vim pod-defination.yml
i
apiVersion: v1
kind: Pod
metadata:
 name: mypod1
 labels:
  author: Mohit
  type: Dev
  server: webserver
spec:
 containers:
  - name: n1
    image: nginx
:wq!


kubectl create -f pod-defination.yml

==========
Labels: Plays very important role in kubernetes.

some examples:
--------
kubectl get pods --show-labels

kubectl get pods -l type=webserver

kubectl get pods -l author=mohit

==========================

Replicaset: 

KIND:     ReplicaSet
VERSION:  apps/v1

DESCRIPTION:
     ReplicaSet ensures that a specified number of pod replicas are running at
     any given time.

FIELDS:
   apiVersion   <string>
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources

   kind <string>
     Kind is a string value representing the REST resource this object
     represents. Servers may infer this from the endpoint the client submits
     requests to. Cannot be updated. In CamelCase. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds

   metadata     <Object>
     If the Labels of a ReplicaSet are empty, they are defaulted to be the same
     as the Pod(s) that the ReplicaSet manages. Standard object's metadata. More
     info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata

   spec <Object>
     Spec defines the specification of the desired behavior of the ReplicaSet.
     More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

   status       <Object>
     Status is the most recently observed status of the ReplicaSet. This data
     may be out of date by some window of time. Populated by the system.
     Read-only. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
     
     
========
Example:
---------------
Template: 
----------------
Note: Before creating replica set, we will set selector with matchLabels having type "ABC" in this case. It should match to the labels provided in template's labels.


apiVersion: myapps/v1
kind: ReplicaSet
metadata:
spec:
 replicas:
 selector:
  matchLabels:
   type: ABC
 template:
  metadata:
   name:
   labels:
    type: ABC
  spec:
===================


vim rs-definition.yml
i

apiVersion: apps/v1
kind: ReplicaSet
metadata:
 name: myrs
spec:
 replicas: 3
 selector:
  matchLabels:
   type: webserver
 template:
  metadate:
   name: My-tomcat
   labels:
    author: Mohit
    type: webserver
  spec:
   containers:
    - name: mynz
      image: tomcat

:wq!

kubectl create -f rs-definition.yml  >>> This will create replicaset.

kubectl get all 

kubectl describe rs myrs

================
Custom command to get image running on pods
-------------
kubectl get pods -o=custom=PodName:.metadata.name,Containers:.spec.containers[*].name, Image:.spec.containers[*].image


===============
Service Object: Service object are used for external network connectivity to Pods. i.e Port maping. Service object is always created for running pods.


3 types of Service Objects:
1. NodePort. { Port mapping from host port to Pod port}
2. LoadBalancer. { Give external ip for communication }
3. ClusterIP. { Used for communication between Pods }

For Port mapping we need to give 3 ports details: 

1. Nodeport ie. the port of host
2. Service port ie port for service object created for pods.
3. Pod port ie the port on pod to access the application.

KIND:     Service
VERSION:  v1
DESCRIPTION:
     Service is a named abstraction of software service (for example, mysql)
     consisting of local port (for example 3306) that the proxy listens on, and
     the selector that determines which pods will answer requests sent through
     the proxy.
FIELDS:
   apiVersion   <string>
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
   kind <string>
     Kind is a string value representing the REST resource this object
     represents. Servers may infer this from the endpoint the client submits
     requests to. Cannot be updated. In CamelCase. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
   metadata     <Object>
     Standard object's metadata. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
   spec <Object>
     Spec defines the behavior of a service.
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   status       <Object>
     Most recently observed status of the service. Populated by the system.
     Read-only. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status

==============
Template:
==============

vim myservice.yaml
i

apiVersion: v1
kind: Service
metadata:
spec:
 type:
 por
 ts:
  - targetPort: ie on the conatiner.
    port: Service port
    nodePort: ie on the host { range between 30000 - 32672 }
 selector:
  type:
 i 
  
===============
example : NodePort >> nodeport needed since it will do maping from external environment. NodePort>>ServicePort>>TargetPort. 
===============

apiVersion: v1
kind: Service
metadata:
 name: myservice
spec:
 type: NodePort
 ports:
  - targetPort: 80
    port: 8181
    nodePort: 30008
 selector:
  type: webserver
  
===============
Example: LoadBalancer >> NodePort not needed since external ip will be assigned
===============

apiVersion: v1
kind: Service
metadata:
 name: LoadbalancerService
spec:
 type: LoadBalancer
 ports:
  - targetPort: 80
    node: 8181
 selector:
  type: webserver
  
==================

Deployment Object >> Same as Replicaset but with additional feature of image update. 
Note : In replica set, once containers are deployed that image will remain in container, we can't update the image. 
To achieve ferquent upgrades, Deployment is used. 

========

KIND:     Deployment
VERSION:  apps/v1

DESCRIPTION:
     Deployment enables declarative updates for Pods and ReplicaSets.

FIELDS:
   apiVersion   <string>
     APIVersion defines the versioned schema of this representation of an
     object. Servers should convert recognized schemas to the latest internal
     value, and may reject unrecognized values. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources

   kind <string>
     Kind is a string value representing the REST resource this object
     represents. Servers may infer this from the endpoint the client submits
     requests to. Cannot be updated. In CamelCase. More info:
     https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds

   metadata     <Object>
     Standard object metadata.

   spec <Object>
     Specification of the desired behavior of the Deployment.

   status       <Object>
     Most recently observed status of the Deployment.

===============
Template: 
===============

apiVersion:
kind:
metadata:
spec:
 replicas:
 minReadySeconds: 
 strategy:
  type: RollingUpdate
  rollingUpdate:
   maxUnavailable:
   maxSurge:
 selector:
  matchLabels:
   type:
 template:
  metadata:
  spec:
  
  =================
  Example:
  =================
  
  apiVersion: apps/v1
  kind: Deployment
  metadata:
   name: mydeployment
  spec:
   replicas: 3
   minReadySeconds: 10
   strategy:
    type: RollingUpdate
    rollingUpdate:
     maxUnavailable: 1
     maxSurge: 1
   selector:
    matchLabels:
     type: webservers
    template:
     metadata:
      name: mywebpod
      labels:
       author: mohit
       type: webservers
     spec:
      containers:
       - name: c1
         image: leaddevops/kubeserve:v1
         
---

  
  
  








